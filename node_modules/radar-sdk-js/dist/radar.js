import maplibregl from 'maplibre-gl';

class Config {
    static setup(options = {}) {
        Config.options = options;
    }
    static get() {
        return Config.options || {};
    }
    static clear() {
        Config.options = {};
    }
}
Config.defaultOptions = {
    live: false,
    logLevel: 'error',
    host: 'https://api.radar.io',
    version: 'v1',
    debug: false,
};

const LOG_LEVELS = {
    none: 0,
    error: 1,
    warn: 2,
    info: 3,
    debug: 4,
};
// get the numeric level for logLevel option
const getLevel = () => {
    // disable logging in tests
    if (window && window.RADAR_TEST_ENV) {
        return LOG_LEVELS.none;
    }
    const { logLevel, debug } = Config.get();
    if (debug) {
        return LOG_LEVELS.debug;
    }
    if (logLevel) {
        return LOG_LEVELS[logLevel];
    }
    return LOG_LEVELS.error; // default to error-level logging if not set
};
class Logger {
    static debug(message, options) {
        if (getLevel() === LOG_LEVELS.debug) {
            console.log(`Radar SDK (debug): ${message.trim()}`, options);
        }
    }
    static info(message) {
        if (getLevel() >= LOG_LEVELS.info) {
            console.log(`Radar SDK: ${message.trim()}`);
        }
    }
    static warn(message) {
        if (getLevel() >= LOG_LEVELS.warn) {
            console.warn(`Radar SDK: ${message.trim()}`);
        }
    }
    static error(message) {
        if (getLevel() >= LOG_LEVELS.error) {
            console.error(`Radar SDK: ${message.trim()}`);
        }
    }
}

class Storage {
    // local storage key definitions for identifying track users
    static get USER_ID() {
        return 'radar-userId';
    }
    static get DEVICE_ID() {
        return 'radar-deviceId';
    }
    static get INSTALL_ID() {
        return 'radar-installId';
    }
    static get SESSION_ID() {
        return 'radar-sessionId';
    }
    static get DESCRIPTION() {
        return 'radar-description';
    }
    static get METADATA() {
        return 'radar-metadata';
    }
    static get CACHED_LOCATION() {
        return 'radar-cached-location';
    }
    static get TRIP_OPTIONS() {
        return 'radar-trip-options';
    }
    static getStorage() {
        const storage = window === null || window === void 0 ? void 0 : window.localStorage;
        if (!storage) {
            Logger.warn('localStorage not available.');
        }
        return storage;
    }
    static setItem(key, value) {
        const storage = this.getStorage();
        if (!storage) {
            return;
        }
        if (value === undefined || value === null) {
            return;
        }
        storage.setItem(key, value);
    }
    static getItem(key) {
        const storage = this.getStorage();
        if (!storage) {
            return null;
        }
        const value = storage.getItem(key);
        if (value !== undefined && value !== null) {
            return value;
        }
        return null;
    }
    static getJSON(key) {
        const item = this.getItem(key);
        if (!item) {
            return null;
        }
        try {
            return JSON.parse(item);
        }
        catch (err) {
            Logger.warn(`could not getJSON from storage for key: ${key}`);
            return null;
        }
    }
    static removeItem(key) {
        const storage = this.getStorage();
        if (!storage) {
            return null;
        }
        storage.removeItem(key);
    }
    static clear() {
        const storage = this.getStorage();
        if (!storage) {
            return null;
        }
        storage.clear();
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class RadarError extends Error {
    constructor(message) {
        super(message);
        this.status = ''; // to be overridden (support for legacy status)
    }
}
class RadarPublishableKeyError extends RadarError {
    constructor(message) {
        super(message);
        this.name = 'RadarPublishableKeyError';
        this.status = 'ERROR_PUBLISHABLE_KEY';
    }
}
class RadarLocationError extends RadarError {
    constructor(message) {
        super(message);
        this.name = 'RadarLocationError';
        this.status = 'ERROR_LOCATION';
    }
}
class RadarPermissionsError extends RadarError {
    constructor(message) {
        super(message);
        this.name = 'RadarPermissionsError';
        this.status = 'ERROR_PERMISSIONS';
    }
}
class RadarVerifyAppError extends RadarError {
    constructor() {
        super('Radar Verify app not running.');
        this.name = 'RadarVerifyAppError';
        this.status = 'ERROR_VERIFY_APP';
    }
}
// HTTP Errors
class RadarBadRequestError extends RadarError {
    constructor(response) {
        var _a;
        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Bad request.');
        this.name = 'RadarBadRequestError';
        this.code = 400;
        this.response = response;
        this.status = 'ERROR_BAD_REQUEST';
    }
}
class RadarUnauthorizedError extends RadarError {
    constructor(response) {
        var _a;
        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Unauthorized.');
        this.name = 'RadarUnauthorizedError';
        this.code = 401;
        this.response = response;
        this.status = 'ERROR_UNAUTHORIZED';
    }
}
class RadarPaymentRequiredError extends RadarError {
    constructor(response) {
        var _a;
        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Payment required.');
        this.name = 'RadarPaymentRequiredError';
        this.code = 402;
        this.response = response;
        this.status = 'ERROR_PAYMENT_REQUIRED';
    }
}
class RadarForbiddenError extends RadarError {
    constructor(response) {
        var _a;
        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Forbidden.');
        this.name = 'RadarForbiddenError';
        this.code = 403;
        this.response = response;
        this.status = 'ERROR_FORBIDDEN';
    }
}
class RadarNotFoundError extends RadarError {
    constructor(response) {
        var _a;
        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Not found.');
        this.name = 'RadarNotFoundError';
        this.code = 404;
        this.response = response;
        this.status = 'ERROR_NOT_FOUND';
    }
}
class RadarRateLimitError extends RadarError {
    constructor(response) {
        var _a, _b;
        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Rate limit exceeded.');
        this.name = 'RadarRateLimitError';
        this.code = 429;
        this.response = response;
        this.type = (_b = response === null || response === void 0 ? void 0 : response.meta) === null || _b === void 0 ? void 0 : _b.type;
        this.status = 'ERROR_RATE_LIMIT';
    }
}
class RadarServerError extends RadarError {
    constructor(response) {
        var _a;
        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Internal server error.');
        this.name = 'RadarServerError';
        this.response = response;
        this.status = 'ERROR_SERVER';
    }
}
class RadarNetworkError extends RadarError {
    constructor() {
        super('Request timed out.');
        this.name = 'RadarNetworkError';
        this.status = 'ERROR_NETWORK';
    }
}
class RadarUnknownError extends RadarError {
    constructor(response) {
        var _a;
        super(((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Something went wrong.');
        this.name = 'RadarUnknownError';
        this.response = response;
        this.status = 'ERROR_UNKNOWN';
    }
}
class RadarAutocompleteContainerNotFound extends RadarError {
    constructor(message) {
        super(message);
        this.name = 'RadarAutocompleteContainerNotFound';
        this.status = 'CONTAINER_NOT_FOUND';
    }
}

const DEFAULT_POSITION_OPTIONS = {
    maximumAge: 0,
    timeout: 1000 * 10,
    enableHighAccuracy: true,
};
// set "enableHighAccuracy" for navigator only when desiredAccuracy is "high"
const useHighAccuracy = (desiredAccuracy) => (Boolean(desiredAccuracy === 'high'));
class Navigator {
    static getCurrentPosition(overrides = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const options = Config.get();
                if (!navigator || !navigator.geolocation) {
                    return reject(new RadarLocationError('navigator.geolocation is not available.'));
                }
                // use cached location if available and options are set
                if (options.cacheLocationMinutes) {
                    try {
                        const rawCachedLocation = Storage.getItem(Storage.CACHED_LOCATION);
                        if (rawCachedLocation) {
                            const cachedLocation = JSON.parse(rawCachedLocation);
                            const { latitude, longitude, accuracy, expiresAt } = cachedLocation || {};
                            if (Date.now() < parseInt(expiresAt)) {
                                if (latitude && longitude && accuracy) {
                                    return resolve({ latitude, longitude, accuracy });
                                }
                            }
                        }
                    }
                    catch (e) {
                        Logger.warn('could not load cached location.');
                    }
                }
                // set options from config
                const positionOptions = Object.assign({}, DEFAULT_POSITION_OPTIONS);
                if (options.locationMaximumAge !== undefined) {
                    positionOptions.maximumAge = options.locationMaximumAge;
                }
                if (options.locationTimeout !== undefined) {
                    positionOptions.timeout = options.locationTimeout;
                }
                if (options.desiredAccuracy !== undefined) {
                    positionOptions.enableHighAccuracy = useHighAccuracy(options.desiredAccuracy);
                }
                // set options from overrides
                if (overrides.desiredAccuracy !== undefined) {
                    positionOptions.enableHighAccuracy = useHighAccuracy(overrides.desiredAccuracy);
                }
                Logger.info(`Using geolocation options: ${JSON.stringify(positionOptions)}`);
                // get current location from browser
                navigator.geolocation.getCurrentPosition((position) => {
                    if (!position || !position.coords) {
                        return reject(new RadarLocationError('device location return empty coordinates.'));
                    }
                    const { latitude, longitude, accuracy } = position.coords;
                    // cache location if option is set
                    if (options.cacheLocationMinutes) {
                        const cacheLocationMinutes = Number.parseFloat(options.cacheLocationMinutes);
                        const updatedAt = Date.now();
                        const expiresAt = updatedAt + (cacheLocationMinutes * 60 * 1000); // convert to ms
                        const lastLocation = { latitude, longitude, accuracy, updatedAt, expiresAt };
                        Storage.setItem(Storage.CACHED_LOCATION, JSON.stringify(lastLocation));
                    }
                    return resolve({ latitude, longitude, accuracy });
                }, (err) => {
                    if (err && err.code === 1) {
                        // https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError
                        // code 1 means location permissions denied
                        // codes 2 and 3 mean location unavailable or timeout
                        return reject(new RadarPermissionsError('Location permissions denied.'));
                    }
                    return reject(new RadarLocationError('Could not determine location.'));
                }, positionOptions);
            });
        });
    }
    static getPermissionStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (!navigator || !navigator.permissions) {
                    return reject(new RadarLocationError('navigator.permissions is not available.'));
                }
                navigator.permissions.query({ name: 'geolocation' }).then((permissionsStatus) => {
                    let locationAuthorization = 'NOT_DETERMINED';
                    switch (permissionsStatus.state) {
                        case 'granted':
                            locationAuthorization = 'GRANTED_FOREGROUND';
                            break;
                        case 'denied':
                            locationAuthorization = 'DENIED';
                            break;
                        case 'prompt':
                            locationAuthorization = 'NOT_DETERMINED';
                            break;
                    }
                    return resolve(locationAuthorization);
                });
            });
        });
    }
}

var SDK_VERSION = '4.4.10';

const inFlightRequests = new Map();
class Http {
    static request({ method, path, data, host, version, headers = {}, responseType, requestId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const options = Config.get();
                // check for publishableKey on request
                const publishableKey = options.publishableKey;
                if (!publishableKey) {
                    reject(new RadarPublishableKeyError('publishableKey not set.'));
                    return;
                }
                // setup request URL
                const urlHost = host || options.host;
                const urlVersion = version || options.version;
                let url = `${urlHost}/${urlVersion}/${path}`;
                // remove undefined values from request data
                let body = {};
                Object.keys(data || {}).forEach((key) => {
                    const value = data[key];
                    if (value !== undefined) {
                        body[key] = value;
                    }
                });
                // convert data to querystring for GET requests
                if (method === 'GET') {
                    const params = Object.keys(body).map((key) => (`${key}=${encodeURIComponent(body[key])}`));
                    if (params.length > 0) {
                        const queryString = params.join('&');
                        url = `${url}?${queryString}`;
                    }
                    body = undefined; // dont send body for GET request
                }
                // check for in-flight requests with matching requestIds
                if (requestId) {
                    const request = inFlightRequests.get(requestId);
                    if (request) {
                        request.abort(); // abort request
                    }
                }
                const xhr = new XMLHttpRequest();
                xhr.open(method, url, true);
                // save reference to request
                if (requestId) {
                    inFlightRequests.set(requestId, xhr);
                }
                const defaultHeaders = {
                    'Authorization': publishableKey,
                    'Content-Type': 'application/json',
                    'X-Radar-Device-Type': 'Web',
                    'X-Radar-SDK-Version': SDK_VERSION,
                };
                // set custom config headers if present
                let configHeaders = {};
                if (typeof options.getRequestHeaders === 'function') {
                    configHeaders = options.getRequestHeaders();
                }
                // combines default headers with custom headers and config headers
                const allHeaders = Object.assign(defaultHeaders, configHeaders, headers);
                // set headers
                Object.keys(allHeaders).forEach((key) => {
                    xhr.setRequestHeader(key, allHeaders[key]);
                });
                if (responseType) {
                    xhr.responseType = responseType;
                }
                xhr.onload = () => {
                    var _a;
                    let response;
                    if (requestId) { // clear in-flight request
                        inFlightRequests.delete(requestId);
                    }
                    try {
                        if (xhr.responseType === 'blob') {
                            response = { code: xhr.status, data: xhr.response };
                        }
                        else {
                            response = JSON.parse(xhr.response);
                        }
                    }
                    catch (e) {
                        return reject(new RadarServerError(response));
                    }
                    const error = (_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.error;
                    if (error === 'ERROR_PERMISSIONS') {
                        return reject(new RadarPermissionsError('Location permissions not granted.'));
                    }
                    else if (error === 'ERROR_LOCATION') {
                        return reject(new RadarLocationError('Could not determine location.'));
                    }
                    else if (error === 'ERROR_NETWORK') {
                        return reject(new RadarNetworkError());
                    }
                    if (xhr.status == 200) {
                        return resolve(response);
                    }
                    if (options.debug) {
                        Logger.debug(`API call failed: ${url}`);
                        Logger.debug(JSON.stringify(response));
                    }
                    if (xhr.status === 400) {
                        reject(new RadarBadRequestError(response));
                    }
                    else if (xhr.status === 401) {
                        reject(new RadarUnauthorizedError(response));
                    }
                    else if (xhr.status === 402) {
                        reject(new RadarPaymentRequiredError(response));
                    }
                    else if (xhr.status === 403) {
                        reject(new RadarForbiddenError(response));
                    }
                    else if (xhr.status === 404) {
                        reject(new RadarNotFoundError(response));
                    }
                    else if (xhr.status === 429) {
                        reject(new RadarRateLimitError(response));
                    }
                    else if (500 <= xhr.status && xhr.status < 600) {
                        reject(new RadarServerError(response));
                    }
                    else {
                        reject(new RadarUnknownError(response));
                    }
                };
                xhr.onerror = function () {
                    if (host && (host === 'http://localhost:52516' || host === 'https://radar-verify.com:52516')) {
                        reject(new RadarVerifyAppError());
                    }
                    else {
                        reject(new RadarNetworkError());
                    }
                };
                xhr.ontimeout = function () {
                    if (host && (host === 'http://localhost:52516' || host === 'https://radar-verify.com:52516')) {
                        reject(new RadarVerifyAppError());
                    }
                    else {
                        reject(new RadarNetworkError());
                    }
                };
                xhr.send(JSON.stringify(body));
            });
        });
    }
}

class AddressesAPI {
    static validateAddress(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            const response = yield Http.request({
                method: 'GET',
                path: 'addresses/validate',
                data: params,
            });
            const { address, result } = response;
            const validateAddressRes = {
                address,
                result,
            };
            if (options.debug) {
                validateAddressRes.response = response;
            }
            return validateAddressRes;
        });
    }
}

const generateUUID = () => {
    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (char) => {
        const r = Math.random() * 16 | 0;
        const v = (char == 'x') ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
    return uuid;
};
class Device {
    static getDeviceId() {
        // use existing deviceId if present
        const deviceId = Storage.getItem(Storage.DEVICE_ID);
        if (deviceId) {
            return deviceId;
        }
        // generate new deviceId
        const uuid = generateUUID();
        Storage.setItem(Storage.DEVICE_ID, uuid);
        return uuid;
    }
    static getInstallId() {
        // use existing installId if present
        const deviceId = Storage.getItem(Storage.INSTALL_ID);
        if (deviceId) {
            return deviceId;
        }
        // generate new installId
        const uuid = generateUUID();
        Storage.setItem(Storage.INSTALL_ID, uuid);
        return uuid;
    }
}

const SESSION_TIMEOUT_SECS = 300; // 5 mins
const isValid = (sessionId) => {
    const now = Math.trunc(Date.now() / 1000);
    const session = Number.parseInt(sessionId);
    const diff = Math.abs(now - session);
    return diff < SESSION_TIMEOUT_SECS;
};
class Session {
    static getSessionId() {
        const sessionId = Storage.getItem(Storage.SESSION_ID);
        // reuse session if still within 5 min threshold
        if (sessionId && isValid(sessionId)) {
            return sessionId;
        }
        // create new session if does not already exist or expired
        const newSessionId = Math.trunc(Date.now() / 1000).toString(); // unix ts in seconds
        Storage.setItem(Storage.SESSION_ID, newSessionId);
        return newSessionId;
    }
}

class ConfigAPI {
    static getConfig(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            if (options.version != 'v1') {
                Logger.info('Skipping /config call.');
                return;
            }
            const deviceId = params.deviceId || Device.getDeviceId();
            const installId = params.installId || Device.getInstallId();
            const sessionId = Session.getSessionId();
            const locationAuthorization = yield Navigator.getPermissionStatus();
            const data = {
                deviceId,
                installId,
                sessionId,
                locationAuthorization,
            };
            try {
                yield Http.request({
                    method: 'GET',
                    path: 'config',
                    data,
                });
            }
            catch (err) {
                Logger.warn(`Error calling /config: ${err.message}`);
            }
        });
    }
}

class ContextAPI {
    static getContext(location) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            // get device location if coordinates not provided
            if (!location.latitude || !location.longitude) {
                location = yield Navigator.getCurrentPosition();
            }
            const { latitude, longitude, accuracy } = location;
            const response = yield Http.request({
                method: 'GET',
                path: 'context',
                data: {
                    coordinates: `${latitude},${longitude}`,
                    accuracy,
                },
            });
            const { geofences, place, country, state, dma, postalCode, } = response;
            const contextRes = {
                location,
                geofences,
                place,
                country,
                state,
                dma,
                postalCode,
            };
            if (options.debug) {
                contextRes.response = response;
            }
            return contextRes;
        });
    }
}

class ConversionsAPI {
    static logConversion(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            const name = params.name;
            const userId = params.userId || Storage.getItem(Storage.USER_ID);
            const deviceId = params.deviceId || Device.getDeviceId();
            const installId = params.installId || Device.getInstallId();
            const metadata = params.metadata || {};
            const createdAt = params.createdAt;
            if (params.revenue) {
                metadata.revenue = params.revenue;
            }
            const data = {
                name,
                userId,
                deviceId,
                installId,
                metadata,
            };
            if (typeof createdAt === 'string') {
                data.createdAt = createdAt;
            }
            else if (createdAt instanceof Date) {
                data.createdAt = createdAt.toISOString();
            }
            else {
                data.createdAt = (new Date()).toISOString();
            }
            const response = yield Http.request({
                method: 'POST',
                path: 'events',
                data,
            });
            const conversionRes = {
                event: response.event,
            };
            if (options.debug) {
                conversionRes.response = response;
            }
            return conversionRes;
        });
    }
}

class Geocoding {
    static forwardGeocode(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            const { query, layers, country, lang } = params;
            const response = yield Http.request({
                method: 'GET',
                path: 'geocode/forward',
                data: {
                    query,
                    layers,
                    country,
                    lang,
                },
            });
            const forwardGeocodeRes = {
                addresses: response.addresses,
            };
            if (options.debug) {
                forwardGeocodeRes.response = response;
            }
            return forwardGeocodeRes;
        });
    }
    static reverseGeocode(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            let { latitude, longitude, layers } = params;
            if (!latitude || !longitude) {
                const location = yield Navigator.getCurrentPosition();
                latitude = location.latitude;
                longitude = location.longitude;
            }
            const response = yield Http.request({
                method: 'GET',
                path: 'geocode/reverse',
                data: {
                    coordinates: `${latitude},${longitude}`,
                    layers,
                },
            });
            const reverseGeocodeRes = {
                addresses: response.addresses,
            };
            if (options.debug) {
                reverseGeocodeRes.response = response;
            }
            return reverseGeocodeRes;
        });
    }
    static ipGeocode() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            const response = yield Http.request({
                method: 'GET',
                path: 'geocode/ip',
            });
            const ipGeocodeRes = {
                ip: response.ip,
                address: response.address,
                proxy: response.proxy,
            };
            if (options.debug) {
                ipGeocodeRes.response = response;
            }
            return ipGeocodeRes;
        });
    }
}

class RoutingAPI {
    static distance(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            let { origin, destination, modes, units, geometry, geometryPoints, avoid, } = params;
            // use browser location if "near" not provided
            if (!origin) {
                const { latitude, longitude } = yield Navigator.getCurrentPosition();
                origin = `${latitude},${longitude}`;
            }
            else if (typeof origin !== 'string') { // origin is "Location" object
                const { latitude, longitude } = origin;
                origin = `${latitude},${longitude}`;
            }
            if (typeof destination !== 'string') {
                const { latitude, longitude } = destination;
                destination = `${latitude},${longitude}`;
            }
            if (Array.isArray(modes)) {
                modes = modes.join(',');
            }
            if (Array.isArray(avoid)) {
                avoid = avoid.join(',');
            }
            const response = yield Http.request({
                method: 'GET',
                path: 'route/distance',
                data: {
                    origin,
                    destination,
                    modes,
                    units,
                    geometry,
                    geometryPoints,
                    avoid,
                },
            });
            const distanceRes = {
                routes: response.routes,
            };
            if (options.debug) {
                distanceRes.response = response;
            }
            return distanceRes;
        });
    }
    static matrix(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            let { origins, destinations, mode, units, avoid, } = params;
            // use browser location if "near" not provided
            if (!origins) {
                const { latitude, longitude } = yield Navigator.getCurrentPosition();
                let originStrings = [];
                for (let i = 0; i < destinations.length; i++) {
                    originStrings.push(`${latitude},${longitude}`);
                }
                origins = originStrings.join('|');
            }
            else if (Array.isArray(origins)) { // origin is a list of "Location" objects
                origins = origins.map((location) => `${location.latitude},${location.longitude}`).join('|');
            }
            // convert array to pipe-delimited string
            if (Array.isArray(destinations)) {
                destinations = destinations.map((location) => `${location.latitude},${location.longitude}`).join('|');
            }
            if (Array.isArray(avoid)) {
                avoid = avoid.join(',');
            }
            const response = yield Http.request({
                method: 'GET',
                path: 'route/matrix',
                data: {
                    origins,
                    destinations,
                    mode,
                    units,
                    avoid,
                },
            });
            const matrixRes = {
                origins: response.origins,
                destinations: response.destinations,
                matrix: response.matrix,
            };
            if (options.debug) {
                matrixRes.response = response;
            }
            return matrixRes;
        });
    }
}

class SearchAPI {
    static autocomplete(params, requestId) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            let { query, near, limit, layers, countryCode, expandUnits, mailable, lang, postalCode, } = params;
            // near can be provided as a string or Location object
            // if "near" is not provided, request will fallback to IP based location
            if (near && typeof near !== 'string') {
                if (near.latitude && near.longitude) {
                    near = `${near.latitude},${near.longitude}`;
                }
            }
            const response = yield Http.request({
                method: 'GET',
                path: 'search/autocomplete',
                data: {
                    query,
                    near,
                    limit,
                    layers,
                    countryCode,
                    expandUnits,
                    mailable,
                    lang,
                    postalCode,
                },
                requestId,
            });
            const autocompleteRes = {
                addresses: response.addresses,
            };
            if (options.debug) {
                autocompleteRes.response = response;
            }
            return autocompleteRes;
        });
    }
    static searchGeofences(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            let { near, radius, tags, metadata, limit, includeGeometry, } = params;
            // use browser location if "near" not provided
            if (!near) {
                const { latitude, longitude } = yield Navigator.getCurrentPosition();
                near = `${latitude},${longitude}`;
            }
            else if (typeof near !== 'string') { // near is "Location" object
                const { latitude, longitude } = near;
                near = `${latitude},${longitude}`;
            }
            // convert arrays to comma-strings
            if (Array.isArray(tags)) {
                tags = tags.join(',');
            }
            const response = yield Http.request({
                method: 'GET',
                path: 'search/geofences',
                data: {
                    near,
                    radius,
                    tags,
                    metadata,
                    limit,
                    includeGeometry,
                },
            });
            const geofencesSearchRes = {
                geofences: response.geofences,
            };
            if (options.debug) {
                geofencesSearchRes.response = response;
            }
            return geofencesSearchRes;
        });
    }
    static searchPlaces(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            let { near, radius, chains, categories, groups, limit, } = params;
            // use browser location if "near" not provided
            if (!near) {
                const { latitude, longitude } = yield Navigator.getCurrentPosition();
                near = `${latitude},${longitude}`;
            }
            else if (typeof near !== 'string') { // near is "Location" object
                const { latitude, longitude } = near;
                near = `${latitude},${longitude}`;
            }
            // convert arrays to comma-strings
            if (Array.isArray(chains)) {
                chains = chains.join(',');
            }
            if (Array.isArray(categories)) {
                categories = categories.join(',');
            }
            if (Array.isArray(groups)) {
                groups = groups.join(',');
            }
            const response = yield Http.request({
                method: 'GET',
                path: 'search/places',
                data: {
                    near,
                    radius,
                    chains,
                    categories,
                    groups,
                    limit,
                },
            });
            const placeSearchRes = {
                places: response.places,
            };
            if (options.debug) {
                placeSearchRes.response = response;
            }
            return placeSearchRes;
        });
    }
}

// https://stackoverflow.com/a/44198641
const isValidDate = (date) => date && Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date);
class TripsAPI {
    static setTripOptions(tripOptions) {
        if (!tripOptions) {
            TripsAPI.clearTripOptions();
            return;
        }
        const tripOptionsString = JSON.stringify(tripOptions);
        Logger.debug(`Saving trip options: ${tripOptionsString}`);
        Storage.setItem(Storage.TRIP_OPTIONS, tripOptionsString);
    }
    static getTripOptions() {
        let tripOptions = Storage.getItem(Storage.TRIP_OPTIONS);
        if (tripOptions) {
            tripOptions = JSON.parse(tripOptions);
        }
        return tripOptions;
    }
    static clearTripOptions() {
        Storage.removeItem(Storage.TRIP_OPTIONS);
    }
    static startTrip(tripOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            tripOptions = tripOptions || TripsAPI.getTripOptions();
            if (!tripOptions) {
                Logger.warn('tripOptions not set when calling "startTrip"');
            }
            const userId = tripOptions.userId || Storage.getItem(Storage.USER_ID);
            if (userId && userId !== Storage.getItem(Storage.USER_ID)) {
                // set as userId for tracking if provided
                Storage.setItem(Storage.USER_ID, userId);
            }
            const { externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, } = tripOptions;
            const data = {
                userId,
                externalId,
                destinationGeofenceTag,
                destinationGeofenceExternalId,
                mode,
                metadata,
                approachingThreshold,
            };
            if (isValidDate(scheduledArrivalAt)) {
                data.scheduledArrivalAt = scheduledArrivalAt === null || scheduledArrivalAt === void 0 ? void 0 : scheduledArrivalAt.toJSON();
            }
            else {
                if (scheduledArrivalAt) {
                    Logger.warn('Invalid date format for scheduledArrivalAt');
                }
                data.scheduledArrivalAt = undefined;
            }
            const response = yield Http.request({
                method: 'POST',
                path: 'trips',
                data,
            });
            // save trip options
            TripsAPI.setTripOptions(tripOptions);
            const tripRes = {
                trip: response.trip,
                events: response.events,
            };
            if (options.debug) {
                tripRes.response = response;
            }
            return tripRes;
        });
    }
    static updateTrip(tripOptions, status) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            tripOptions = tripOptions || TripsAPI.getTripOptions();
            if (!tripOptions) {
                Logger.warn('tripOptions not set when calling "startTrip"');
            }
            const { externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, } = tripOptions;
            const data = {
                status,
                externalId,
                destinationGeofenceTag,
                destinationGeofenceExternalId,
                mode,
                metadata,
                approachingThreshold,
            };
            if (isValidDate(scheduledArrivalAt)) {
                data.scheduledArrivalAt = scheduledArrivalAt === null || scheduledArrivalAt === void 0 ? void 0 : scheduledArrivalAt.toJSON();
            }
            else {
                if (scheduledArrivalAt) {
                    Logger.warn('Invalid date format for scheduledArrivalAt');
                }
                data.scheduledArrivalAt = undefined;
            }
            const response = yield Http.request({
                method: 'PATCH',
                path: `trips/${externalId}/update`,
                data,
            });
            const tripRes = {
                trip: response.trip,
                events: response.events,
            };
            if (options.debug) {
                tripRes.response = response;
            }
            return tripRes;
        });
    }
    static completeTrip() {
        return __awaiter(this, void 0, void 0, function* () {
            const tripOptions = TripsAPI.getTripOptions();
            const tripResponse = yield TripsAPI.updateTrip(tripOptions, 'completed');
            // clear local trip options
            TripsAPI.clearTripOptions();
            return tripResponse;
        });
    }
    static cancelTrip() {
        return __awaiter(this, void 0, void 0, function* () {
            const tripOptions = TripsAPI.getTripOptions();
            const tripResponse = yield TripsAPI.updateTrip(tripOptions, 'canceled');
            // clear local trip options
            TripsAPI.clearTripOptions();
            return tripResponse;
        });
    }
}

const base64Encode = (str) => btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
const signJWT = (payload, key) => __awaiter(void 0, void 0, void 0, function* () {
    const encoder = new TextEncoder();
    const encodedHeader = base64Encode(JSON.stringify({
        alg: 'HS256',
        typ: 'JWT',
    }));
    const encodedPayload = base64Encode(JSON.stringify(payload));
    const keyData = encoder.encode(key);
    const messageData = encoder.encode(`${encodedHeader}.${encodedPayload}`);
    const cryptoKey = yield crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);
    const signatureArrayBuffer = yield crypto.subtle.sign('HMAC', cryptoKey, messageData);
    const signature = base64Encode(String.fromCharCode(...Array.from(new Uint8Array(signatureArrayBuffer))));
    return `${encodedHeader}.${encodedPayload}.${signature}`;
});

class TrackAPI {
    static trackOnce(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            let { latitude, longitude, accuracy, desiredAccuracy, fraud } = params;
            // if latitude & longitude are not provided,
            // try and retrieve device location (will prompt for location permissions)
            if (!latitude || !longitude) {
                const deviceLocation = yield Navigator.getCurrentPosition({ desiredAccuracy });
                latitude = deviceLocation.latitude;
                longitude = deviceLocation.longitude;
                accuracy = deviceLocation.accuracy;
            }
            // location authorization
            let locationAuthorization;
            try {
                locationAuthorization = yield Navigator.getPermissionStatus();
            }
            catch (err) {
                Logger.warn(`Location authorization error: ${err.message}`);
            }
            // user indentification fields
            const userId = params.userId || Storage.getItem(Storage.USER_ID);
            const deviceId = params.deviceId || Device.getDeviceId();
            const installId = params.installId || Device.getInstallId();
            const sessionId = Session.getSessionId();
            const deviceType = params.deviceType || 'Web';
            const description = params.description || Storage.getItem(Storage.DESCRIPTION);
            let timeZone;
            try {
                timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            }
            catch (err) {
                Logger.warn(`Error getting time zone: ${err.message}`);
            }
            // save userId for trip tracking
            if (!userId) {
                Logger.warn('userId not provided for trackOnce.');
            }
            else {
                Storage.setItem(Storage.USER_ID, userId);
            }
            // other info
            const metadata = params.metadata || Storage.getJSON(Storage.METADATA);
            // trips
            const tripOptions = params.tripOptions || TripsAPI.getTripOptions();
            if (tripOptions) {
                tripOptions.version = '2';
            }
            const body = Object.assign(Object.assign({}, params), { locationAuthorization,
                accuracy,
                description,
                deviceId,
                deviceType, foreground: true, installId,
                sessionId,
                latitude,
                longitude,
                metadata, sdkVersion: SDK_VERSION, stopped: true, userId,
                tripOptions,
                timeZone });
            let response;
            if (fraud) {
                const host = 'https://api-verified.radar.io';
                const lang = navigator.language;
                const langs = navigator.languages;
                const { dk } = yield Http.request({
                    host,
                    method: 'GET',
                    path: 'config',
                    data: {
                        deviceId,
                        installId,
                        sessionId,
                        locationAuthorization,
                    },
                    headers: {
                        'X-Radar-Desktop-Device-Type': 'Web',
                    },
                });
                const payload = {
                    payload: JSON.stringify(Object.assign(Object.assign({}, body), { lang,
                        langs })),
                };
                const reqToken = yield signJWT(payload, dk);
                response = yield Http.request({
                    host,
                    method: 'POST',
                    path: 'track',
                    data: {
                        token: reqToken,
                    },
                    headers: {
                        'X-Radar-Body-Is-Token': 'true',
                    },
                });
                let { user, events, token, expiresAt, expiresIn, passed, failureReasons, _id } = response;
                const location = { latitude, longitude, accuracy };
                if (expiresAt) {
                    expiresAt = new Date(expiresAt);
                }
                const trackRes = {
                    user,
                    events,
                    location,
                    token,
                    expiresAt,
                    expiresIn,
                    passed,
                    failureReasons,
                    _id,
                };
                if (options.debug) {
                    trackRes.response = response;
                }
                return trackRes;
            }
            response = yield Http.request({
                method: 'POST',
                path: 'track',
                data: body,
            });
            const { user, events } = response;
            const location = { latitude, longitude, accuracy };
            const trackRes = {
                user,
                events,
                location,
            };
            if (options.debug) {
                trackRes.response = response;
            }
            return trackRes;
        });
    }
}

let tokenTimeoutId = null;
let tokenCallback = null;
let lastToken = null;
let lastTokenNow = 0;
let expectedCountryCode = null;
let expectedStateCode = null;
class VerifyAPI {
    static trackVerified(params, encrypted = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Config.get();
            const { skipVerifyApp } = params;
            // user indentification fields
            const userId = params.userId || Storage.getItem(Storage.USER_ID);
            const deviceId = Device.getDeviceId();
            const installId = Device.getInstallId();
            const sessionId = Session.getSessionId();
            const description = params.description || Storage.getItem(Storage.DESCRIPTION);
            // save userId
            if (!userId) {
                Logger.warn('userId not provided for trackVerified.');
            }
            else {
                Storage.setItem(Storage.USER_ID, userId);
            }
            // other info
            const metadata = params.metadata || Storage.getJSON(Storage.METADATA);
            let trackRes;
            if (skipVerifyApp) {
                trackRes = yield TrackAPI.trackOnce({
                    userId: userId !== null && userId !== void 0 ? userId : undefined,
                    description: description !== null && description !== void 0 ? description : undefined,
                    metadata: metadata,
                    fraud: true,
                });
            }
            else {
                const body = Object.assign(Object.assign({}, params), { description,
                    deviceId, foreground: true, installId,
                    sessionId,
                    metadata, sdkVersion: SDK_VERSION, stopped: true, userId,
                    encrypted,
                    expectedCountryCode,
                    expectedStateCode });
                let userAgent = navigator.userAgent;
                const apple = userAgent && (userAgent.toLowerCase().includes('mac') || userAgent.toLowerCase().includes('iphone') || userAgent.toLowerCase().includes('ipod') || userAgent.toLowerCase().includes('ipad'));
                const response = yield Http.request({
                    method: 'GET',
                    path: 'verify',
                    data: body,
                    host: apple ? 'https://radar-verify.com:52516' : 'http://localhost:52516',
                });
                let { user, events, token, expiresAt, expiresIn, passed, failureReasons, _id } = response;
                let location;
                if (user && user.location && user.location.coordinates && user.locationAccuracy) {
                    location = {
                        latitude: user.location.coordinates[1],
                        longitude: user.location.coordinates[0],
                        accuracy: user.locationAccuracy,
                    };
                }
                if (expiresAt) {
                    expiresAt = new Date(expiresAt);
                }
                trackRes = {
                    user,
                    events,
                    location,
                    token,
                    expiresAt,
                    expiresIn,
                    passed,
                    failureReasons,
                    _id,
                };
                if (options.debug) {
                    trackRes.response = response;
                }
            }
            lastToken = trackRes;
            lastTokenNow = performance.now();
            if (tokenCallback) {
                tokenCallback(trackRes);
            }
            return trackRes;
        });
    }
    static startTrackingVerified(params) {
        const scheduleNextIntervalWithLastToken = () => __awaiter(this, void 0, void 0, function* () {
            const { interval } = params;
            let minInterval = interval;
            if (lastToken) {
                const lastTokenElapsed = (performance.now() - lastTokenNow) / 1000;
                const expiresIn = (lastToken.expiresIn || 0);
                // if expiresIn is shorter than interval, override interval
                // re-request early to maximize the likelihood that a cached token is available
                minInterval = Math.min(expiresIn - lastTokenElapsed, interval);
            }
            minInterval = minInterval - 10;
            // min interval is 10 seconds
            if (minInterval < 10) {
                minInterval = 10;
            }
            if (tokenTimeoutId) {
                clearTimeout(tokenTimeoutId);
            }
            tokenTimeoutId = setTimeout(doTrackVerified, minInterval * 1000);
        });
        const doTrackVerified = () => __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.trackVerified(params);
            }
            catch (err) {
                Logger.error(`trackVerified error: ${err.message}`);
            }
            scheduleNextIntervalWithLastToken();
        });
        if (this.isLastTokenValid()) {
            scheduleNextIntervalWithLastToken();
        }
        else {
            doTrackVerified();
        }
    }
    static stopTrackingVerified() {
        if (tokenTimeoutId) {
            clearTimeout(tokenTimeoutId);
        }
    }
    static getVerifiedLocationToken(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isLastTokenValid()) {
                return lastToken;
            }
            return this.trackVerified(params);
        });
    }
    static clearVerifiedLocationToken() {
        lastToken = null;
    }
    static isLastTokenValid() {
        if (!lastToken) {
            return false;
        }
        const lastTokenElapsed = (performance.now() - lastTokenNow) / 1000;
        return lastToken.passed && lastTokenElapsed < (lastToken.expiresIn || 0);
    }
    static setExpectedJurisdiction(countryCode, stateCode) {
        expectedCountryCode = countryCode || null;
        expectedStateCode = stateCode || null;
    }
    static onTokenUpdated(callback) {
        tokenCallback = callback;
    }
}

const isSecretKey = (key) => (key.includes('_sk_'));
const isLiveKey = (key) => (key.includes('_live_'));
let Radar$1 = class Radar {
    static get VERSION() {
        return SDK_VERSION;
    }
    static initialize(publishableKey, options = {}) {
        if (!publishableKey) {
            throw new RadarPublishableKeyError('Publishable key required in initialization.');
        }
        if (isSecretKey(publishableKey)) {
            throw new RadarPublishableKeyError('Secret keys are not allowed. Please use your Radar publishable key.');
        }
        // store settings in global config
        const live = isLiveKey(publishableKey);
        const logLevel = live ? 'error' : 'info';
        const debug = !live;
        const radarOptions = Object.assign(Config.defaultOptions, {
            publishableKey,
            live,
            logLevel,
            debug,
        }, options);
        Config.setup(radarOptions);
        Logger.info(`initialized with ${live ? 'live' : 'test'} publishableKey.`);
        if (options.debug) {
            Logger.debug('using options', options);
        }
        // NOTE(jasonl): this allows us to run jest tests
        // without having to mock the ConfigAPI.getConfig call
        if (!(window === null || window === void 0 ? void 0 : window.RADAR_TEST_ENV)) {
            ConfigAPI.getConfig();
        }
    }
    static clear() {
        Config.clear();
    }
    ///////////////////////
    // Geofencing Platform
    ///////////////////////
    static setUserId(userId) {
        if (!userId) {
            Storage.removeItem(Storage.USER_ID);
            return;
        }
        Storage.setItem(Storage.USER_ID, String(userId).trim());
    }
    static setDescription(description) {
        if (!description) {
            Storage.removeItem(Storage.DESCRIPTION);
            return;
        }
        Storage.setItem(Storage.DESCRIPTION, String(description).trim());
    }
    static setMetadata(metadata) {
        if (!metadata) {
            Storage.removeItem(Storage.METADATA);
            return;
        }
        Storage.setItem(Storage.METADATA, JSON.stringify(metadata));
    }
    static getLocation() {
        return Navigator.getCurrentPosition();
    }
    static trackOnce(params = {}) {
        try {
            return TrackAPI.trackOnce(params);
        }
        finally {
            ConfigAPI.getConfig(params); // call with updated permissions
        }
    }
    static trackVerified(params = {}) {
        return VerifyAPI.trackVerified(params);
    }
    static startTrackingVerified(params) {
        VerifyAPI.startTrackingVerified(params);
    }
    static stopTrackingVerified() {
        VerifyAPI.stopTrackingVerified();
    }
    static getVerifiedLocationToken(params = {}) {
        return VerifyAPI.getVerifiedLocationToken(params);
    }
    static clearVerifiedLocationToken() {
        VerifyAPI.clearVerifiedLocationToken();
    }
    static setExpectedJurisdiction(countryCode, stateCode) {
        VerifyAPI.setExpectedJurisdiction(countryCode, stateCode);
    }
    static getContext(params) {
        return ContextAPI.getContext(params);
    }
    static setTripOptions(tripOptions) {
        TripsAPI.setTripOptions(tripOptions);
    }
    static clearTripOptions() {
        TripsAPI.clearTripOptions();
    }
    static getTripOptions() {
        return TripsAPI.getTripOptions();
    }
    static startTrip(tripOptions) {
        return TripsAPI.startTrip(tripOptions);
    }
    static updateTrip(tripOptions) {
        return TripsAPI.updateTrip(tripOptions);
    }
    static completeTrip() {
        return TripsAPI.completeTrip();
    }
    static cancelTrip() {
        return TripsAPI.cancelTrip();
    }
    static logConversion(params) {
        return ConversionsAPI.logConversion(params);
    }
    ///////////////////////
    // Listeners
    ///////////////////////
    static onTokenUpdated(callback) {
        VerifyAPI.onTokenUpdated(callback);
    }
    /////////////////
    // Maps Platform
    /////////////////
    static forwardGeocode(params) {
        return Geocoding.forwardGeocode(params);
    }
    static reverseGeocode(params) {
        return Geocoding.reverseGeocode(params);
    }
    static ipGeocode() {
        return Geocoding.ipGeocode();
    }
    static autocomplete(params) {
        return SearchAPI.autocomplete(params);
    }
    static searchGeofences(params) {
        return SearchAPI.searchGeofences(params);
    }
    static searchPlaces(params) {
        return SearchAPI.searchPlaces(params);
    }
    static validateAddress(params) {
        return AddressesAPI.validateAddress(params);
    }
    static distance(params) {
        return RoutingAPI.distance(params);
    }
    static matrix(params) {
        return RoutingAPI.matrix(params);
    }
};

class RadarFeatureMouseEvent {
    constructor(type, feature, originalEvent) {
        this.type = type;
        this.feature = feature;
        this.originalEvent = originalEvent;
    }
}
class RadarMapFeature {
    constructor(map, feature) {
        var _a;
        this._sourceIds = [];
        this._layerIds = [];
        this.id = ((_a = feature.id) !== null && _a !== void 0 ? _a : `feature-${Date.now()}`).toString();
        // check for duplicate IDs
        (map.getFeatures() || []).forEach((feature) => {
            if (feature.id === this.id) {
                throw new Error(`RadarMapFeature: feature with id ${this.id} already exists.`);
            }
        });
        this.geometry = feature.geometry;
        this.properties = feature.properties || {};
        this._feature = feature;
        this._map = map;
    }
    remove() {
        // remove layers
        this._layerIds.forEach((layerId) => {
            if (this._map.getLayer(layerId)) {
                this._map.removeLayer(layerId);
            }
        });
        // remove source
        this._sourceIds.forEach((sourceId) => {
            if (this._map.getSource(sourceId)) {
                this._map.removeSource(sourceId);
            }
        });
        // remove reference from map
        this._map._features = this._map._features.filter((other) => other.id !== this.id);
    }
    // register events with feature layer
    on(eventType, callback) {
        this._map.on(eventType, this.id, (event) => {
            callback(new RadarFeatureMouseEvent(eventType, this, event));
        });
        // add pointer cursor if feature is clickable
        if (eventType === 'click') {
            this._map.on('mouseenter', this.id, () => {
                this._map.getCanvas().style.cursor = 'pointer';
            });
            this._map.on('mouseleave', this.id, () => {
                this._map.getCanvas().style.cursor = '';
            });
        }
    }
}

/**
 * https://github.com/mapbox/polyline
 *
 * Decodes to a [longitude, latitude] coordinates array.
 *
 * This is adapted from the implementation in Project-OSRM.
 *
 * see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js
 *
 */
const decodePolyline = (str, precision = 6) => {
    let index = 0;
    let lat = 0;
    let lng = 0;
    let coordinates = [];
    let shift = 0;
    let result = 0;
    let byte = null;
    let latitudeChange;
    let longitudeChange;
    let factor = Math.pow(10, precision || 6);
    // Coordinates have variable length when encoded, so just keep
    // track of whether we've hit the end of the string. In each
    // loop iteration, a single coordinate is decoded.
    while (index < str.length) {
        // Reset shift, result, and byte
        byte = null;
        shift = 0;
        result = 0;
        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);
        latitudeChange = result & 1 ? ~(result >> 1) : result >> 1;
        shift = result = 0;
        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);
        longitudeChange = result & 1 ? ~(result >> 1) : result >> 1;
        lat += latitudeChange;
        lng += longitudeChange;
        coordinates.push([lng / factor, lat / factor]);
    }
    return coordinates;
};

// remove fields with undefined values from object
// (top-level only)
const filterUndefined = (object) => {
    const obj = {};
    Object.entries(object).forEach(([key, value]) => {
        if (value !== undefined) {
            obj[key] = value;
        }
    });
    return obj;
};
// deep merge nested objects - returns a new object
// (arrays are concatenated)
const mergeDeep = (target, source = {}) => {
    let output = Object.assign({}, target);
    for (const key in source) {
        if (source[key] instanceof Object && !Array.isArray(source[key]) && key in target) {
            output[key] = mergeDeep(target[key], source[key]);
        }
        else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
            output[key] = target[key].concat(source[key]);
        }
        else {
            output[key] = source[key];
        }
    }
    return output;
};

const defaultLineOptions = {
    paint: {
        'line-cap': 'round',
        'line-color': '#000257',
        'line-width': 4,
        'border-color': '#FFFFFF',
        'border-width': 2,
    }
};
class RadarLineFeature extends RadarMapFeature {
    constructor(map, feature, lineOptions) {
        super(map, feature);
        const featureId = this.id;
        const options = mergeDeep(defaultLineOptions, lineOptions);
        // use a callback to account for the async loading of the map
        const addFeatureToMap = () => {
            options.paint = options.paint || {};
            // add source for feature
            map.addSource(featureId, { type: 'geojson', data: feature });
            this._sourceIds.push(featureId);
            // add border layer if border styling is present
            if (options.paint['line-width'] && options.paint['border-width']) {
                const borderLayerId = `${featureId}-border`;
                const borderWidth = options.paint['line-width'] + options.paint['border-width'];
                map.addLayer({
                    id: borderLayerId,
                    source: featureId,
                    type: 'line',
                    layout: {
                        'line-cap': options.paint['line-cap'],
                    },
                    paint: filterUndefined({
                        'line-color': options.paint['border-color'],
                        'line-opacity': options.paint['border-opacity'],
                        'line-width': borderWidth,
                    }),
                });
                this._layerIds.push(borderLayerId); // border layer
            }
            // line-layer
            map.addLayer({
                id: featureId,
                source: featureId,
                type: 'line',
                layout: {
                    'line-cap': options.paint['line-cap'],
                },
                paint: filterUndefined({
                    'line-color': options.paint['line-color'],
                    'line-width': options.paint['line-width'],
                    'line-opacity': options.paint['line-opacity'],
                    'line-offset': options.paint['line-offset'],
                    'line-blur': options.paint['line-blur'],
                    'line-dasharray': options.paint['line-dasharray'],
                    'line-gap-width': options.paint['line-gap-width'],
                    'line-gradient': options.paint['line-gradient'],
                }),
            });
            this._layerIds.push(featureId); // line layer
        };
        // ensure map is ready before modifying source and layers
        if (map.loaded()) {
            addFeatureToMap();
        }
        else {
            map.once('data', () => {
                addFeatureToMap();
            });
        }
        return this;
    }
    static fromPolyline(map, polyline, polylineOptions) {
        const featureId = (polylineOptions === null || polylineOptions === void 0 ? void 0 : polylineOptions.id) || `polyline-feature-${Date.now()}`;
        const coordinates = decodePolyline(polyline, polylineOptions === null || polylineOptions === void 0 ? void 0 : polylineOptions.precision);
        const feature = {
            id: featureId,
            type: 'Feature',
            geometry: {
                type: 'LineString',
                coordinates,
            },
            properties: (polylineOptions === null || polylineOptions === void 0 ? void 0 : polylineOptions.properties) || {},
        };
        const lineFeature = new RadarLineFeature(map, feature, polylineOptions);
        return lineFeature;
    }
}

const defaultPolygonOptions = {
    paint: {
        'fill-color': '#FF6F00',
        'fill-opacity': 0.3,
        'border-color': '#FF6F00',
        'border-opacity': 1,
        'border-width': 2,
    }
};
class RadarPolygonFeature extends RadarMapFeature {
    constructor(map, feature, polygonOptions) {
        super(map, feature);
        const featureId = this.id;
        const options = mergeDeep(defaultPolygonOptions, polygonOptions);
        // use a callback to account for the async loading of the map
        const addFeatureToMap = () => {
            options.paint = options.paint || {};
            // add source for feature
            map.addSource(featureId, { type: 'geojson', data: feature });
            this._sourceIds.push(featureId);
            // polygon-layer
            map.addLayer({
                id: featureId,
                source: featureId,
                type: 'fill',
                layout: {},
                paint: filterUndefined({
                    'fill-color': options.paint['fill-color'],
                    'fill-opacity': options.paint['fill-opacity'],
                }),
            });
            this._layerIds.push(featureId);
            // border layer
            if (options.paint['border-color'] && options.paint['border-width'] && options.paint['border-opacity']) {
                let borderLayerId = `${featureId}-border`;
                map.addLayer({
                    id: borderLayerId,
                    source: featureId,
                    type: 'line',
                    layout: {},
                    paint: filterUndefined({
                        'line-color': options.paint['border-color'],
                        'line-opacity': options.paint['border-opacity'],
                        'line-width': options.paint['border-width'],
                    }),
                });
                this._layerIds.push(borderLayerId);
            }
        };
        // ensure map is ready before modifying source and layers
        if (map.loaded()) {
            addFeatureToMap();
        }
        else {
            map.once('data', () => {
                addFeatureToMap();
            });
        }
        return this;
    }
}

const RADAR_LOGO_URL = 'https://api.radar.io/maps/static/images/logo.svg';
class RadarLogoControl {
    onAdd() {
        const img = document.createElement('img');
        img.src = RADAR_LOGO_URL;
        img.alt = 'Radar Maps Platform';
        this.link = document.createElement('a');
        this.link.id = 'radar-map-logo';
        this.link.href = 'https://radar.com?ref=powered_by_radar';
        this.link.target = '_blank';
        this.link.style.pointerEvents = "auto";
        this.link.appendChild(img);
        return this.link;
    }
    onRemove() {
        var _a;
        (_a = this.link) === null || _a === void 0 ? void 0 : _a.remove();
    }
}

const append = (dest, src) => {
    src.forEach((coord) => {
        dest.push(coord);
    });
};
// return array of all coordinates in a feature
const getCoords = (feature) => {
    const coordinates = [];
    const geometry = feature.geometry;
    switch (geometry.type) {
        case 'Point':
            coordinates.push(geometry.coordinates);
            break;
        case 'MultiPoint':
        case 'LineString':
            append(coordinates, geometry.coordinates);
            break;
        case 'MultiLineString':
        case 'Polygon':
            geometry.coordinates.forEach(coords => append(coordinates, coords));
            break;
        case 'MultiPolygon':
            geometry.coordinates.forEach(polygon => {
                polygon.forEach(coords => append(coordinates, coords));
            });
            break;
        default:
            return coordinates;
    }
    return coordinates;
};
// return all coordinates from a list of feature
const getAllCoords = (features) => {
    const coordinates = [];
    (features || []).forEach((feature) => {
        const coords = getCoords(feature);
        coords.forEach((coord) => {
            coordinates.push(coord);
        });
    });
    return coordinates;
};

const DEFAULT_STYLE = 'radar-default-v1';
const RADAR_STYLES = [
    'radar-default-v1',
    'radar-light-v1',
    'radar-dark-v1',
];
// Radar specific configs
const defaultRadarMapOptions = {
    showZoomControls: true,
};
const defaultMaplibreOptions = {
    minZoom: 1,
    maxZoom: 20,
    attributionControl: false,
    dragRotate: false,
    touchPitch: false,
    maplibreLogo: false,
};
const defaultFitMarkersOptions = {
    padding: 50,
};
const createStyleURL = (options, mapOptions) => {
    const style = mapOptions.style || DEFAULT_STYLE;
    let url = `${options.host}/maps/styles/${style}`;
    if (mapOptions.language) {
        url += `?language=${mapOptions.language}`;
    }
    return url;
};
// check if style is a Radar style or a custom style
const isRadarStyle = (style) => {
    if (RADAR_STYLES.includes(style)) { // Radar built-in style
        return true;
    }
    if (!/^(http:|https:)/.test(style)) { // Radar custom style (not a URL)
        return true;
    }
    return false;
};
// use formatted style URL if using one of Radar's out-of-the-box styles or is a Radar custom style
const getStyle = (options, mapOptions) => {
    const style = mapOptions.style;
    if (!style || (typeof style === 'string' && isRadarStyle(style))) {
        return createStyleURL(options, mapOptions);
    }
    return mapOptions.style; // style object or URL
};
class RadarMap extends maplibregl.Map {
    constructor(radarMapOptions) {
        const config = Config.get();
        if (!config.publishableKey) {
            Logger.warn('publishableKey not set. Call Radar.initialize() with key before creating a new map.');
        }
        // configure map options
        const style = getStyle(config, radarMapOptions);
        const mapOptions = Object.assign({}, defaultRadarMapOptions, defaultMaplibreOptions, radarMapOptions, { style });
        Logger.debug('map initialized with options', mapOptions);
        mapOptions.transformRequest = (url, resourceType) => {
            // this handles when a style is switched
            if (resourceType === 'Style' && isRadarStyle(url)) {
                url = createStyleURL(config, Object.assign(Object.assign({}, mapOptions), { style: url }));
            }
            let headers = {
                'Authorization': config.publishableKey,
                'X-Radar-Device-Type': 'Web',
                'X-Radar-SDK-Version': SDK_VERSION,
            };
            if (typeof config.getRequestHeaders === 'function') {
                headers = Object.assign(headers, config.getRequestHeaders());
            }
            return { url, headers };
        };
        super(mapOptions); // initialize MapLibre instance
        this._markers = [];
        this._features = [];
        const container = this.getContainer();
        if (!container.style.width && !container.style.height) {
            Logger.warn('map container does not have a set "width" or "height"');
        }
        // add radar logo
        const radarLogo = new RadarLogoControl();
        this.addControl(radarLogo, 'bottom-left');
        // add attribution
        const attribution = new maplibregl.AttributionControl({ compact: false });
        this.addControl(attribution, 'bottom-right');
        // add zoom controls
        const nav = new maplibregl.NavigationControl({
            showCompass: false,
            showZoom: mapOptions.showZoomControls,
        });
        this.addControl(nav, 'bottom-right');
        // handle map resize actions
        const onResize = () => {
            const attrib = document.querySelector('.maplibregl-ctrl-attrib');
            if (attrib) {
                const width = this.getContainer().clientWidth;
                if (width < 380) {
                    attrib.classList.add('hidden');
                }
                else {
                    attrib.classList.remove('hidden');
                }
            }
        };
        this.on('resize', onResize);
        this.on('load', onResize);
    }
    addMarker(marker) {
        this._markers.push(marker);
    }
    removeMarker(marker) {
        this._markers = this._markers.filter((mapMarker) => mapMarker !== marker);
    }
    getMarkers() {
        return this._markers;
    }
    fitToMarkers(fitBoundsOptions = {}, overrideMarkers) {
        const markers = overrideMarkers || this.getMarkers();
        if (markers.length === 0) {
            return;
        }
        const bounds = new maplibregl.LngLatBounds();
        markers.forEach((marker) => {
            bounds.extend(marker.getLngLat());
        });
        const options = Object.assign(defaultFitMarkersOptions, fitBoundsOptions);
        this.fitBounds(bounds, options);
    }
    clearMarkers() {
        this._markers.forEach((marker) => {
            marker.remove();
        });
    }
    getFeatures() {
        return this._features;
    }
    fitToFeatures(fitBoundsOptions = {}, overrideFeatures) {
        const features = (overrideFeatures || this._features).map((mapFeature) => mapFeature._feature);
        const coords = getAllCoords(features);
        if (coords.length > 0) {
            const bounds = new maplibregl.LngLatBounds();
            coords.forEach((coord) => {
                bounds.extend(coord);
            });
            this.fitBounds(bounds, fitBoundsOptions);
        }
    }
    // remove all features from the map
    clearFeatures() {
        this._features.forEach((feature) => {
            feature.remove();
        });
    }
    addPolygon(polygon, polygonOptions) {
        const feature = new RadarPolygonFeature(this, polygon, polygonOptions);
        this._features.push(feature);
        return feature;
    }
    addLine(line, lineOptions) {
        const feature = new RadarLineFeature(this, line, lineOptions);
        this._features.push(feature);
        return feature;
    }
    addPolyline(polyline, polylineOptions) {
        const feature = RadarLineFeature.fromPolyline(this, polyline, polylineOptions);
        this._features.push(feature);
        return feature;
    }
}

class RadarMarkerMouseEvent {
    constructor(type, marker, originalEvent) {
        this.target = marker;
        this.originalEvent = originalEvent;
        this.point = marker._pos;
        this.lngLat = marker.getLngLat();
        this.type = type;
    }
}
// cache URL loaded markers
const IMAGE_CACHE = new Map();
const useCachedImage = (url, timeoutMS = 5000) => new Promise((resolve, reject) => {
    if (!IMAGE_CACHE.has(url)) { // nothing in cache
        IMAGE_CACHE.set(url, 'pending'); // request in flight
        return reject('miss');
    }
    const start = Date.now();
    const interval = setInterval(() => {
        const cachedData = IMAGE_CACHE.get(url);
        if (cachedData === 'pending') {
            if ((Date.now() - start) > timeoutMS) { // cache lookup took too long
                clearInterval(interval);
                reject('timed out');
            }
        }
        else if (cachedData === 'failed') { // request failed
            clearInterval(interval);
            reject('failed');
        }
        else if (cachedData !== undefined) { // return data
            clearInterval(interval);
            resolve(cachedData);
        }
    }, 100);
});
const createImageElement = (options) => {
    const element = document.createElement('img');
    element.src = options.url;
    if (options.width) {
        if (typeof options.width === 'number') {
            element.width = options.width;
        }
        else {
            element.style.width = options.width;
        }
    }
    if (options.height) {
        if (typeof options.height === 'number') {
            element.height = options.height;
        }
        else {
            element.style.height = options.height;
        }
    }
    if (!options.width && !options.height) {
        element.style.maxWidth = '64px';
        element.style.maxHeight = '64px';
        element.style.width = '100%';
        element.style.height = '100%';
    }
    return element;
};
const defaultMarkerOptions = {
    color: '#000257',
};
class RadarMarker extends maplibregl.Marker {
    constructor(markerOptions) {
        const maplibreOptions = Object.assign({}, defaultMarkerOptions);
        // init MapLibre marker configs
        if (markerOptions.color) {
            maplibreOptions.color = markerOptions.color;
        }
        if (markerOptions.element) {
            maplibreOptions.element = markerOptions.element;
        }
        if (markerOptions.scale) {
            maplibreOptions.scale = markerOptions.scale;
        }
        super(maplibreOptions);
        // handle marker images (Radar marker, or custom URL)
        if (markerOptions.marker || markerOptions.url) {
            const originalElement = this._element.cloneNode(true);
            this._element.childNodes.forEach((child) => {
                child.remove();
            });
            const onSuccess = (url) => {
                this._element.replaceChildren(createImageElement({
                    width: markerOptions.width,
                    height: markerOptions.height,
                    url,
                }));
            };
            const onError = (err) => {
                Logger.error(`Could not load marker: ${err.message} - falling back to default marker`);
                IMAGE_CACHE.set(markerOptions.url, 'failed'); // mark as failed
                this._element.replaceChildren(...Array.from(originalElement.childNodes));
            };
            // custom URL image
            if (markerOptions.url) {
                const loadImage = () => {
                    fetch(markerOptions.url)
                        .then(res => {
                        if (res.status === 200) {
                            res.blob()
                                .then((data) => {
                                const url = URL.createObjectURL(data);
                                IMAGE_CACHE.set(markerOptions.url, url); // cache data
                                onSuccess(url);
                            })
                                .catch(onError);
                        }
                        else {
                            onError(new Error(res.statusText));
                        }
                    })
                        .catch(onError);
                };
                // attempt to use cached data, otherwise fetch marker image data from URL
                useCachedImage(markerOptions.url)
                    .then(onSuccess)
                    .catch((reason) => {
                    if (reason !== 'miss') {
                        Logger.debug(`RadarMarker: cache lookup for ${markerOptions.url}: ${reason}`);
                    }
                    loadImage();
                });
            }
            // Radar hosted image
            if (markerOptions.marker) {
                const loadMarker = () => {
                    Http.request({
                        method: 'GET',
                        version: 'maps',
                        path: `markers/${markerOptions.marker}`,
                        responseType: 'blob',
                    })
                        .then(({ data }) => {
                        const url = URL.createObjectURL(data);
                        IMAGE_CACHE.set(markerOptions.marker, url); // cache data
                        onSuccess(url);
                    })
                        .catch(onError);
                };
                useCachedImage(markerOptions.marker)
                    .then(onSuccess)
                    .catch((reason) => {
                    if (reason !== 'miss') {
                        Logger.debug(`RadarMarker: cache lookup for ${markerOptions.marker} ${reason}`);
                    }
                    loadMarker();
                });
            }
        }
        // handle deprecated popup options
        if (markerOptions.text) {
            Logger.warn('marker option "text" is deprecated, and will be removed in a future version. Use "popup.text".');
            markerOptions.popup = markerOptions.popup || {};
            markerOptions.popup.text = markerOptions.text;
        }
        if (markerOptions.html) {
            Logger.warn('marker option "html" is deprecated, and will be removed in a future version. Use "popup.html".');
            markerOptions.popup = markerOptions.popup || {};
            markerOptions.popup.html = markerOptions.html;
        }
        // set popup text or HTML
        if (markerOptions.popup) {
            const popup = new maplibregl.Popup(markerOptions.popup);
            if (markerOptions.popup.text) {
                popup.setText(markerOptions.popup.text);
            }
            if (markerOptions.popup.html) {
                popup.setHTML(markerOptions.popup.html);
            }
            if (markerOptions.popup.element) {
                popup.setDOMContent(markerOptions.popup.element);
            }
            this.setPopup(popup);
        }
        // pass-through click event from element to marker
        const element = this.getElement();
        if (element) {
            element.addEventListener('click', (e) => {
                e.stopPropagation(); // prevent clicks from propagating to map
                // since we're stopping the propagation to map,
                // we need to manually toggle the popup associated with the marker
                if (this.getPopup()) {
                    // close any other open popups
                    (this._map.getMarkers() || []).forEach((otherMarker) => {
                        var _a;
                        if ((_a = otherMarker.getPopup()) === null || _a === void 0 ? void 0 : _a.isOpen()) {
                            otherMarker.togglePopup();
                        }
                    });
                    this.togglePopup();
                }
                this.fire('click', new RadarMarkerMouseEvent('click', this, e));
            });
        }
    }
    addTo(map) {
        map.addMarker(this);
        return super.addTo(map);
    }
    remove() {
        if (this._map) {
            this._map.removeMarker(this);
        }
        return super.remove();
    }
}

class RadarPopup extends maplibregl.Popup {
    constructor(popupOptions) {
        super(popupOptions);
        if (popupOptions.text) {
            this.setText(popupOptions.text);
        }
        if (popupOptions.html) {
            this.setHTML(popupOptions.html);
        }
        if (popupOptions.element) {
            this.setDOMContent(popupOptions.element);
        }
    }
}

class MapUI {
    static getMapLibre() {
        return maplibregl;
    }
    static createMap(mapOptions) {
        const radarMap = new RadarMap(mapOptions);
        return radarMap;
    }
    static createMarker(markerOptions = {}) {
        const radarMarker = new RadarMarker(markerOptions);
        return radarMarker;
    }
    static createPopup(popupOptions) {
        const popup = new RadarPopup(popupOptions);
        return popup;
    }
}

const CLASSNAMES = {
    WRAPPER: 'radar-autocomplete-wrapper',
    INPUT: 'radar-autocomplete-input',
    SEARCH_ICON: 'radar-autocomplete-search-icon',
    RESULTS_LIST: 'radar-autocomplete-results-list',
    RESULTS_ITEM: 'radar-autocomplete-results-item',
    RESULTS_MARKER: 'radar-autocomplete-results-marker',
    SELECTED_ITEM: 'radar-autocomplete-results-item-selected',
    POWERED_BY_RADAR: 'radar-powered',
    NO_RESULTS: 'radar-no-results',
};
const defaultAutocompleteOptions = {
    container: 'autocomplete',
    debounceMS: 200,
    minCharacters: 3,
    limit: 8,
    placeholder: 'Search address',
    responsive: true,
    disabled: false,
    showMarkers: true,
    hideResultsOnBlur: true,
};
// determine whether to use px or CSS string
const formatCSSValue = (value) => {
    if (typeof value === 'number') {
        return `${value}px`;
    }
    return value;
};
const DEFAULT_WIDTH = 400;
const setWidth = (input, options) => {
    // if responsive and width is provided, treat it as maxWidth
    if (options.responsive) {
        input.style.width = '100%';
        if (options.width) {
            input.style.maxWidth = formatCSSValue(options.width);
        }
        return;
    }
    // if not responsive, set fixed width and unset maxWidth
    input.style.width = formatCSSValue(options.width || DEFAULT_WIDTH);
    input.style.removeProperty('max-width');
};
const setHeight = (resultsList, options) => {
    if (options.maxHeight) {
        resultsList.style.maxHeight = formatCSSValue(options.maxHeight);
        resultsList.style.overflowY = 'auto'; /* allow overflow when maxHeight is applied */
    }
};
const getMarkerIcon = (color = "#ACBDC8") => {
    const fill = color.replace('#', '%23');
    const svg = `<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M12.5704 6.57036C12.5704 4.11632 10.6342 2.11257 8.21016 2C8.14262 2 8.06757 2 8.00003 2C7.93249 2 7.85744 2 7.7899 2C5.35838 2.11257 3.42967 4.11632 3.42967 6.57036C3.42967 6.60037 3.42967 6.6379 3.42967 6.66792C3.42967 6.69794 3.42967 6.73546 3.42967 6.76548C3.42967 9.46717 7.09196 13.3621 7.4672 13.7598C7.61729 13.9174 7.84994 14 8.00003 14C8.15012 14 8.38277 13.9174 8.53286 13.7598C8.9156 13.3621 12.5704 9.46717 12.5704 6.76548C12.5704 6.72795 12.5704 6.69794 12.5704 6.66792C12.5704 6.6379 12.5704 6.60037 12.5704 6.57036ZM7.99252 8.28893C7.04693 8.28893 6.27395 7.52345 6.27395 6.57036C6.27395 5.61726 7.03943 4.85178 7.99252 4.85178C8.94562 4.85178 9.7111 5.61726 9.7111 6.57036C9.7111 7.52345 8.94562 8.28893 7.99252 8.28893Z" fill="${fill}"/>
  </svg>`.trim();
    return `data:image/svg+xml;charset=utf-8,${svg}`;
};
class AutocompleteUI {
    // create a new AutocompleteUI instance
    static createAutocomplete(autocompleteOptions) {
        return new AutocompleteUI(autocompleteOptions);
    }
    constructor(options = {}) {
        this.config = Object.assign({}, defaultAutocompleteOptions, options);
        // setup state
        this.isOpen = false;
        this.debouncedFetchResults = this.debounce(this.fetchResults, this.config.debounceMS);
        this.results = [];
        this.highlightedIndex = -1;
        // set threshold alias
        if (this.config.threshold !== undefined) {
            this.config.minCharacters = this.config.threshold;
            Logger.warn('AutocompleteUI option "threshold" is deprecated, use "minCharacters" instead.');
        }
        if (options.near) {
            if (typeof options.near === 'string') {
                this.near = options.near;
            }
            else {
                this.near = `${options.near.latitude},${options.near.longitude}`;
            }
        }
        // get container element
        let containerEL;
        if (typeof this.config.container === 'string') { // lookup container element by ID
            containerEL = document.getElementById(this.config.container);
        }
        else { // use provided element
            containerEL = this.config.container; // HTMLElement
        }
        if (!containerEL) {
            throw new RadarAutocompleteContainerNotFound(`Could not find container element: ${this.config.container}`);
        }
        this.container = containerEL;
        // create wrapper for input and result list
        this.wrapper = document.createElement('div');
        this.wrapper.classList.add(CLASSNAMES.WRAPPER);
        this.wrapper.style.display = this.config.responsive ? 'block' : 'inline-block';
        setWidth(this.wrapper, this.config);
        // result list element
        this.resultsList = document.createElement('ul');
        this.resultsList.classList.add(CLASSNAMES.RESULTS_LIST);
        this.resultsList.setAttribute('id', CLASSNAMES.RESULTS_LIST);
        this.resultsList.setAttribute('role', 'listbox');
        this.resultsList.setAttribute('aria-live', 'polite');
        this.resultsList.setAttribute('aria-label', 'Search results');
        setHeight(this.resultsList, this.config);
        if (containerEL.nodeName === 'INPUT') {
            // if an <input> element is provided, use that as the inputField,
            // and append the resultList to it's parent container
            this.inputField = containerEL;
            // append to dom
            this.wrapper.appendChild(this.resultsList);
            containerEL.parentNode.appendChild(this.wrapper);
        }
        else {
            // if container is not an input, create new input and append to container
            // create new input
            this.inputField = document.createElement('input');
            this.inputField.classList.add(CLASSNAMES.INPUT);
            this.inputField.placeholder = this.config.placeholder;
            this.inputField.type = 'text';
            this.inputField.disabled = this.config.disabled;
            // search icon
            const searchIcon = document.createElement('div');
            searchIcon.classList.add(CLASSNAMES.SEARCH_ICON);
            // append to DOM
            this.wrapper.appendChild(this.inputField);
            this.wrapper.appendChild(this.resultsList);
            this.wrapper.appendChild(searchIcon);
            this.container.appendChild(this.wrapper);
        }
        // disable browser autofill
        this.inputField.setAttribute('autocomplete', 'off');
        // set aria roles
        this.inputField.setAttribute('role', 'combobox');
        this.inputField.setAttribute('aria-controls', CLASSNAMES.RESULTS_LIST);
        this.inputField.setAttribute('aria-expanded', 'false');
        this.inputField.setAttribute('aria-haspopup', 'listbox');
        this.inputField.setAttribute('aria-autocomplete', 'list');
        this.inputField.setAttribute('aria-activedescendant', '');
        // setup event listeners
        this.inputField.addEventListener('input', this.handleInput.bind(this));
        this.inputField.addEventListener('keydown', this.handleKeyboardNavigation.bind(this));
        if (this.config.hideResultsOnBlur) {
            this.inputField.addEventListener('blur', this.close.bind(this), true);
        }
        Logger.debug('AutocompleteUI initialized with options', this.config);
    }
    handleInput() {
        // Fetch autocomplete results and display them
        const query = this.inputField.value;
        if (query.length < this.config.minCharacters) {
            return;
        }
        this.debouncedFetchResults(query)
            .then((results) => {
            const onResults = this.config.onResults;
            if (onResults) {
                onResults(results);
            }
            this.displayResults(results);
        })
            .catch((error) => {
            Logger.warn(`Autocomplete ui error: ${error.message}`);
            const onError = this.config.onError;
            if (onError) {
                onError(error);
            }
        });
    }
    debounce(fn, delay) {
        let timeoutId;
        let resolveFn;
        let rejectFn;
        return (...args) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                const result = fn.apply(this, args);
                if (result instanceof Promise) {
                    result
                        .then((value) => {
                        if (resolveFn) {
                            resolveFn(value);
                        }
                    })
                        .catch((error) => {
                        if (rejectFn) {
                            rejectFn(error);
                        }
                    });
                }
            }, delay);
            return new Promise((resolve, reject) => {
                resolveFn = resolve;
                rejectFn = reject;
            });
        };
    }
    fetchResults(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { limit, layers, countryCode, expandUnits, mailable, lang, postalCode, onRequest } = this.config;
            const params = {
                query,
                limit,
                layers,
                countryCode,
                expandUnits,
                mailable,
                lang,
                postalCode,
            };
            if (this.near) {
                params.near = this.near;
            }
            if (onRequest) {
                onRequest(params);
            }
            const { addresses } = yield SearchAPI.autocomplete(params, 'autocomplete-ui');
            return addresses;
        });
    }
    displayResults(results) {
        // Clear the previous results
        this.clearResultsList();
        this.results = results;
        let marker;
        if (this.config.showMarkers) {
            marker = document.createElement('img');
            marker.classList.add(CLASSNAMES.RESULTS_MARKER);
            marker.setAttribute('src', getMarkerIcon(this.config.markerColor));
        }
        // Create and append list items for each result
        results.forEach((result, index) => {
            const li = document.createElement('li');
            li.classList.add(CLASSNAMES.RESULTS_ITEM);
            li.setAttribute('role', 'option');
            li.setAttribute('id', `${CLASSNAMES.RESULTS_ITEM}}-${index}`);
            // construct result with bolded label
            let listContent;
            if (result.formattedAddress.includes(result.addressLabel) && result.layer !== 'postalCode') {
                // if addressLabel is contained in the formatted address, bold the address label
                const regex = new RegExp(`(${result.addressLabel}),?`);
                listContent = result.formattedAddress.replace(regex, '<b>$1</b>');
            }
            else {
                // otherwise append the address or place label to formatted address
                const label = result.placeLabel || result.addressLabel;
                listContent = `<b>${label}</b> ${result.formattedAddress}`;
            }
            li.innerHTML = listContent;
            // prepend marker if enabled
            if (marker) {
                li.prepend(marker.cloneNode());
            }
            // add click handler to each result, use mousedown to fire before blur event
            li.addEventListener('mousedown', () => {
                this.select(index);
            });
            this.resultsList.appendChild(li);
        });
        this.open();
        if (results.length > 0) {
            const link = document.createElement('a');
            link.href = 'https://radar.com?ref=powered_by_radar';
            link.target = '_blank';
            this.poweredByLink = link;
            const poweredByText = document.createElement('span');
            poweredByText.textContent = 'Powered by';
            link.appendChild(poweredByText);
            const radarLogo = document.createElement('span');
            radarLogo.id = 'radar-powered-logo';
            radarLogo.textContent = 'Radar';
            link.appendChild(radarLogo);
            const poweredByContainer = document.createElement('div');
            poweredByContainer.classList.add(CLASSNAMES.POWERED_BY_RADAR);
            poweredByContainer.appendChild(link);
            this.resultsList.appendChild(poweredByContainer);
        }
        else {
            const noResultsText = document.createElement('div');
            noResultsText.classList.add(CLASSNAMES.NO_RESULTS);
            noResultsText.textContent = 'No results';
            this.resultsList.appendChild(noResultsText);
        }
    }
    open() {
        if (this.isOpen) {
            return;
        }
        this.inputField.setAttribute('aria-expanded', 'true');
        this.resultsList.removeAttribute('hidden');
        this.isOpen = true;
    }
    close(e) {
        if (!this.isOpen) {
            return;
        }
        // run this code async to allow link click to propagate before blur
        // (add 100ms delay if closed from link click)
        const linkClick = e && (e.relatedTarget === this.poweredByLink);
        setTimeout(() => {
            this.inputField.setAttribute('aria-expanded', 'false');
            this.inputField.setAttribute('aria-activedescendant', '');
            this.resultsList.setAttribute('hidden', '');
            this.highlightedIndex = -1;
            this.isOpen = false;
            this.clearResultsList();
        }, linkClick ? 100 : 0);
    }
    goTo(index) {
        if (!this.isOpen || !this.results.length) {
            return;
        }
        // wrap around
        if (index < 0) {
            index = this.results.length - 1;
        }
        else if (index >= this.results.length) {
            index = 0;
        }
        const resultItems = this.resultsList.getElementsByTagName('li');
        if (this.highlightedIndex > -1) {
            // clear class names on previously highlighted item
            resultItems[this.highlightedIndex].classList.remove(CLASSNAMES.SELECTED_ITEM);
        }
        // add class name to newly highlighted item
        resultItems[index].classList.add(CLASSNAMES.SELECTED_ITEM);
        // set aria active descendant
        this.inputField.setAttribute('aria-activedescendant', `${CLASSNAMES.RESULTS_ITEM}-${index}`);
        this.highlightedIndex = index;
    }
    handleKeyboardNavigation(event) {
        let key = event.key;
        // allow event to propagate if result list is not open
        if (!this.isOpen) {
            return;
        }
        // treat shift+tab as up key
        if (key === 'Tab' && event.shiftKey) {
            key = 'ArrowUp';
        }
        switch (key) {
            // Next item
            case 'Tab':
            case 'ArrowDown':
                event.preventDefault();
                this.goTo(this.highlightedIndex + 1);
                break;
            // Prev item
            case 'ArrowUp':
                event.preventDefault();
                this.goTo(this.highlightedIndex - 1);
                break;
            // Select
            case 'Enter':
                this.select(this.highlightedIndex);
                break;
            // Close
            case 'Esc':
                this.close();
                break;
        }
    }
    select(index) {
        const result = this.results[index];
        if (!result) {
            Logger.warn(`No autocomplete result found at index: ${index}`);
            return;
        }
        let inputValue;
        if (result.formattedAddress.includes(result.addressLabel)) {
            inputValue = result.formattedAddress;
        }
        else {
            const label = result.placeLabel || result.addressLabel;
            inputValue = `${label}, ${result.formattedAddress}`;
        }
        this.inputField.value = inputValue;
        const onSelection = this.config.onSelection;
        if (onSelection) {
            onSelection(result);
        }
        // clear results list
        this.close();
    }
    clearResultsList() {
        this.resultsList.innerHTML = '';
        this.results = [];
    }
    // remove elements from DOM
    remove() {
        Logger.debug('AutocompleteUI removed.');
        this.inputField.remove();
        this.resultsList.remove();
        this.wrapper.remove();
    }
    setNear(near) {
        if (near === undefined || near === null) {
            this.near = undefined;
        }
        else if (typeof near === 'string') {
            this.near = near;
        }
        else {
            this.near = `${near.latitude},${near.longitude}`;
        }
        return this;
    }
    setPlaceholder(placeholder) {
        this.config.placeholder = placeholder;
        this.inputField.placeholder = placeholder;
        return this;
    }
    setDisabled(disabled) {
        this.config.disabled = disabled;
        this.inputField.disabled = disabled;
        return this;
    }
    setResponsive(responsive) {
        this.config.responsive = responsive;
        setWidth(this.wrapper, this.config);
        return this;
    }
    setWidth(width) {
        if (width === null) {
            this.config.width = undefined;
        }
        else if (typeof width === 'string' || typeof width === 'number') {
            this.config.width = width;
        }
        setWidth(this.wrapper, this.config);
        return this;
    }
    setMaxHeight(height) {
        if (height === null) {
            this.config.maxHeight = undefined;
        }
        else if (typeof height === 'string' || typeof height === 'number') {
            this.config.maxHeight = height;
        }
        setHeight(this.resultsList, this.config);
        return this;
    }
    setMinCharacters(minCharacters) {
        this.config.minCharacters = minCharacters;
        this.config.threshold = minCharacters;
        return this;
    }
    setLimit(limit) {
        this.config.limit = limit;
        return this;
    }
    setLang(lang) {
        if (lang === null) {
            this.config.lang = undefined;
        }
        else if (typeof lang === 'string') {
            this.config.lang = lang;
        }
        return this;
    }
    setPostalCode(postalCode) {
        if (postalCode === null) {
            this.config.postalCode = undefined;
        }
        else if (typeof postalCode === 'string') {
            this.config.postalCode = postalCode;
        }
        return this;
    }
    setShowMarkers(showMarkers) {
        this.config.showMarkers = showMarkers;
        if (showMarkers) {
            const marker = document.createElement('img');
            marker.classList.add(CLASSNAMES.RESULTS_MARKER);
            marker.setAttribute('src', getMarkerIcon(this.config.markerColor));
            const resultItems = this.resultsList.getElementsByTagName('li');
            for (let i = 0; i < resultItems.length; i++) {
                const currentMarker = resultItems[i].getElementsByClassName(CLASSNAMES.RESULTS_MARKER)[0];
                if (!currentMarker) {
                    resultItems[i].prepend(marker.cloneNode());
                }
            }
        }
        else {
            const resultItems = this.resultsList.getElementsByTagName('li');
            for (let i = 0; i < resultItems.length; i++) {
                const marker = resultItems[i].getElementsByClassName(CLASSNAMES.RESULTS_MARKER)[0];
                if (marker) {
                    marker.remove();
                }
            }
        }
        return this;
    }
    setMarkerColor(color) {
        this.config.markerColor = color;
        const marker = this.resultsList.getElementsByClassName(CLASSNAMES.RESULTS_MARKER);
        for (let i = 0; i < marker.length; i++) {
            marker[i].setAttribute('src', getMarkerIcon(color));
        }
        return this;
    }
    setHideResultsOnBlur(hideResultsOnBlur) {
        this.config.hideResultsOnBlur = hideResultsOnBlur;
        if (hideResultsOnBlur) {
            this.inputField.addEventListener('blur', this.close.bind(this), true);
        }
        else {
            this.inputField.removeEventListener('blur', this.close.bind(this), true);
        }
        return this;
    }
}

class Radar extends Radar$1 {
    // "ui" namespace for Maps and Autocomplete
    static get ui() {
        return {
            maplibregl: MapUI.getMapLibre(),
            map: MapUI.createMap,
            marker: MapUI.createMarker,
            popup: MapUI.createPopup,
            autocomplete: AutocompleteUI.createAutocomplete,
        };
    }
}

export { Radar as default };
//# sourceMappingURL=radar.js.map
